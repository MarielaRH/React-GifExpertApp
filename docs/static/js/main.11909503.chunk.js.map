{"version":3,"sources":["components/AddCategory.js","helpers/getGift.js","hooks/useFetchGIfs.js","components/GifGridItem.js","components/GifGrid.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cate","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","useFetchGIfs","loading","state","setState","useEffect","then","imgs","GifGridItem","className","src","alt","GifGrid","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAmDeA,EA/CK,SAAC,GAAwB,IAArBC,EAAoB,EAApBA,cAAoB,EAEJC,mBAAS,IAFL,mBAEjCC,EAFiC,KAErBC,EAFqB,KA0BxC,OAEI,aADA,CACA,QAAMC,SAfW,SAACC,GAElBA,EAAEC,iBAGCJ,EAAWK,OAAOC,OAAO,IAExBR,GAAc,SAAAS,GAAI,OAAKP,GAAL,mBAAmBO,OAErCN,EAAc,MAMlB,SAEI,uBAEIO,KAAK,OAELC,MAAQT,EAERU,SAhCc,SAACP,GAMvBF,EAAcE,EAAEQ,OAAOF,a,+BCWhBG,EArBF,uCAAG,WAAMC,GAAN,uBAAAC,EAAA,6DAENC,EAFM,iDAEyCC,UAAUH,GAFnD,+DAIOI,MAAMF,GAJb,cAING,EAJM,gBAOSA,EAAKC,OAPd,uBAOLC,EAPK,EAOLA,KAGDC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MAEXV,IAAG,UAACQ,EAAIG,cAAL,aAAC,EAAYC,iBAAiBZ,QAf7B,kBAkBLM,GAlBK,4CAAH,sDC0BEO,EAzBM,SAACf,GAAa,MAELd,mBAAS,CAC/BqB,KAAM,GACNS,SAAS,IAJkB,mBAExBC,EAFwB,KAEjBC,EAFiB,KAsB/B,OAdAC,qBAAU,WAEPpB,EAAQC,GACPoB,MAAK,SAAAC,GAEFH,EAAS,CACLX,KAAMc,EACNL,SAAS,SAIjB,CAAChB,IAGGiB,GCfIK,EATK,SAAC,GAAmB,EAAlBX,GAAmB,IAAhBC,EAAe,EAAfA,MAAMV,EAAS,EAATA,IAC3B,OACI,sBAAKqB,UAAW,mDAAhB,UACI,qBAAKC,IAAMtB,EAAMuB,IAAMb,IACvB,4BAAKA,QCuDFc,EAvDC,SAAC,GAAgB,IAAf1B,EAAc,EAAdA,SAAc,EAEIe,EAAaf,GAAhCa,EAFe,EAEpBN,KAAaS,EAFO,EAEPA,QAuBrB,OACI,qCAEI,oBAAIO,UAAW,oCAAf,SAAsDvB,IAErDgB,GAAW,mBAAGO,UAAY,mCAAf,wBAEZ,qBAAKA,UAAU,YAAf,SASYV,EAAOJ,KAAI,SAACC,GAAD,OACP,cAAC,EAAD,eAIQA,GAHCA,EAAIC,aCTzBgB,EArCM,WAAM,MAEazC,mBAAS,CAAC,KAFvB,mBAEhB0C,EAFgB,KAEJ3C,EAFI,KAYvB,OACI,qCACI,8CAEA,cAAC,EAAD,CAAaA,cAAiBA,IAC9B,uBAEA,6BAEQ2C,EAAWnB,KAAK,SAAAT,GAAQ,OACpB,cAAC,EAAD,CAAwBA,SAAUA,GAApBA,Y,MCnBvC6B,IAASC,OACP,cAAC,EAAD,IACCC,SAASC,eAAe,W","file":"static/js/main.11909503.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport PropTypes from 'prop-types'\n\n/* desestructuramos setCategories de las props que recibimos */\nconst AddCategory = ({  setCategories }) => {\n    //definimos el estado del input\n    const [inputValue, setInputValue] = useState('');//el valor por defecto del estado, puede ser un string, un objeto, un array, etc\n\n    const handleInputChange = (e) => {\n        /* del event que se dispara podemos sacar el valor que está en el input, para lo cual usamos e.target.value\\\n        con esto podremos escribir dentro de la caja de texto y nuestro estado estará actualizado con lo ultimo que el usuario escribio\n\n        algo muy importante que debemos tener en cuenta es que si nosotros no manejamos el evento onChange, no se nos permitirá cambiar o agregar texto dentro\n        del input, esto se debe a que en ningun momento estamos cambiando el estado de este*/\n        setInputValue(e.target.value);\n    }\n\n    const handleSubmit = (e) => {\n        //con esto estamos previniendo que se recargue la pagina cuando hacemos el envio del formulario\n        e.preventDefault();\n\n        /* validamos que la categoria a añadir no sea undefined */\n        if(inputValue.trim().length>2){\n            /* implementamos el setCategories que viene desde el componente GifExpertApp, y le pasamos como valor a agregar el valor del input */\n            setCategories(cate => [inputValue,...cate]);\n            /* Reiniciamos el valor del input y lo dejamos vacio luego de dar enter y mandar la nueva categoria  */\n            setInputValue('');\n        }\n    }\n\n    return (\n        /*cuando damos enter y tenemos un formulario el navegador refrescar la pagina completa, para prevenir eso agregamos la propiedad onSubmit*/\n        <form onSubmit= {handleSubmit}>\n        {/* Aqui recibiremos la categoria */}\n            <input\n                //ponemos el tipo que recibira nuestro input\n                type='text'\n                //este será el valor que tendrá el input(valor por defecto) y también es el valor que actualizaremos(valor introducido por el usuario)\n                value= {inputValue}\n                //para poder actualizar el value debemos manejar el evento onChange, el cual se disparará cada vez que el input cambie\n                onChange={handleInputChange}\n            />\n        </form>\n    )\n}\n\n/* marcamos como requerido la funcion isCategorie */\nAddCategory.propTypes = {\n    setCategories : PropTypes.func.isRequired,\n}\n\nexport default AddCategory\n","/* Componente encargado del fetch al api \n\npor ser un componen async lo que este retorna es una promesa*/\n\nconst getGifs = async(category) => {\n    /* al pasar la categoria en la url estamos haciendo que coja el valor de la categoria escrita por el usuario y que en base a eso realice la peticion */\n    const url= `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=EZwZDiZj0wPXIknuJkaBuMyqi3sG511y`\n    /* Hacemos una peticion a la url que hemos definido, esta nos devolverá un objeto json con toda la informacion */\n    const resp = await fetch(url);\n    /* Con el metodo .json transformamos el objeto json a un objeto js para poder utilizar la informacion de este, y desestructuramos la informacion que nos interesa\n    que en este caso lo que utilizaremos es lo que está dentro de data*/\n    const {data} = await resp.json();\n\n    /* recorremos la data para extraer solo los datos que nos interesan de la imagen */\n    const gifs = data.map(img => {\n        return {\n            id: img.id,\n            title: img.title,\n            /* hacemos uso del operador ternario para preguntar que si la url viene en las imagenes que la utilice*/\n            url:img.images?.downsized_medium.url\n        }\n    })\n    return gifs; \n}\n\nexport default getGifs;","/* CUSTOM HOOK */\nimport {useEffect, useState} from 'react'\nimport getGifs from '../helpers/getGift'\n\n\nconst useFetchGIfs = (category) => {\n    //definimos el estado del hook\n    const [state, setState] = useState({\n        data: [],\n        loading: true,\n    })\n\n    //establecemos el efecto , cada vez que se monte nuestro componente GifExpretApp se ejecutará el codifo que este dentro\n    useEffect(() => {\n        //llamamos a getGifs que es el encargado de realizar el fetch al API, pero este componente es async por lo tanto nos devolverá una promesa\n       getGifs(category)\n       .then(imgs => {\n           //cargamos en el estado la informacion de todos los gif relacionados a la categoria, que nos devolvio getGif\n           setState({\n               data: imgs,\n               loading: false\n           })\n    })\n\n    }, [category])\n\n\n    return state;\n}\n\nexport default useFetchGIfs\n","import React from 'react'\n\n/* como en el componente GifGrid mandamos las prop con el spread operator([...img]) aqui podemos colocarlas de manera desestructurada  */\nconst GifGridItem = ({id,title,url}) => {\n    return (\n        <div className= \"animate__animated animate__bounce animate__delay\">\n            <img src={ url } alt={ title }></img>\n            <p>{ title }</p>\n        </div>\n    )\n}\n\nexport default GifGridItem","import React from 'react'\nimport useFetchGIfs from '../hooks/useFetchGIfs'\n// import React, { useEffect, useState } from 'react'\n// import getGifs from '../helpers/getGift';\nimport GifGridItem from './GifGridItem';\n\n//recibimos la categoria que viene desde el componente padre, el cual está en el componente GifExpertApp\nconst GifGrid = ({category}) => {\n    //usamos el custom hook useFetchGif\n    const { data:images, loading} = useFetchGIfs(category);\n\n\n    //estado de las imagenes que vamos a recibir del API\n    // const [images, setImages] = useState([])\n\n    /* definimos el estado de un contador para comprension de useEffect */\n    //const [count, setCount] = useState(0);\n\n    /* Si nosotros implementamos el estado del boton del contador y ademas tenemos la llamada de la funcion getGifs a la misma altura que el estado, al detectar cambios provocaría que todo se vuelva a renderizar\n    incluyendo la ejecución de la funcion, para evitar esto, haremos uso de useEffect, el cual nos permite ejecutar codifo específico de manera condicional */\n\n    /* useEffect(() => {\n        //getGifs es la funcion que ejecutaremos de manera condicional\n       getGifs(category)\n       .then(setImages);\n    }, [category]) */\n\n    /* al pasarle al useEffect como segundo parámetro un array vacío estamos indicandole a react que nuestro efecto no depende de ningun valor y por lo tanto las funciones \n    que estén declaradas dentro de useEffect solo deberán ejecutarse al montar y desmontar el componente GifGrid*/\n\n    // getGifs(); llamada a la funcion antes de implementar useEffect\n\n    return (\n        <>\n            {/* los animate son animaciones que hemos implementado de una libreria */}\n            <h3 className={\"animate__animated animate__fadeIn\"}>{ category }</h3>\n            {/* usamos el loading del hook loading*/}\n            {loading && <p className= {\"animate__animated animate__flash\"}>Loading...</p>}\n\n            <div className=\"card-grid\">\n                {/* imprimimos el valor del contador */}\n                {/* <h2>{ count }</h2> */}\n                {/* Habilitamos el evento onClick */}\n                {/* <button onClick={()=>{ setCount( count + 1 ) }}></button> */}\n\n                {/* mostraremos en una lista ordenada el titulo de las imagenes de la API\n                como key vamos a agregar el valor del id que tiene cada imagen */}\n                    {\n                        images.map((img) => (\n                            <GifGridItem\n                                key={img.id}\n                                // enviando argumentos de esta manera nos da una manera mas flexible de manejar las props\n                                // ya que lo que hacemos es mandar cada propiedad, en este caso (id, title, url), como propiedades independientes\n                                {...img}\n                            />\n                        ))\n                    }\n            </div>\n        </>\n    )\n}\n\nexport default GifGrid\n\n\n/* el estado de contador y el boton eran ejemplo para comprender el uso del useEffect */","import React, { useState } from 'react';\nimport AddCategory from './components/AddCategory';\nimport GifGrid from './components/GifGrid';\n\n const GifExpertApp = () => {\n    /* para crear la lista ordenada de categorias podemos usar el estado con un valor inicial y con setCategories podemos agregar mas categorías */\n     const [categories, setCategories] = useState(['']);\n\n     /* const handlerAdd = () => {\n        //Maneras de agregar un elemento a un arreglo por medio del estado\n\n        // setCategories(categories.concat('Naruto'));\n        // setCategories([...categories,'Naruto']);\n        setCategories(cate => [...cate,'Naruto']);// pasamos a setCategorias una funcion que recibe como parametro el estado inicial y devuelve el estado modificado\n     } */\n\n     return (\n         <>\n             <h2>GifExpertApp</h2>\n             {/* aqui le pasamos la referencia de nuestra funcion setCategories para poder agregar nuevas categorias desde el componente AddCategories */}\n             <AddCategory setCategories= { setCategories }/>\n             <hr/>\n            {/*  <button onClick= {handlerAdd}>Agregar</button> */}\n             <ol>\n                 {\n                     categories.map( category => (\n                         <GifGrid key={category} category={category}/>\n                        /* al elemento li debemos colocarle el key unico de cada elemento y para hacerlo podemos colocar la misma categoria que recibimos\n                         esto se hace para no tener un error en la consola del navegador\n\n                         return <li key={categories}>{categories}</li>\n\n\n                         nos traemos el componente encargado de renderizar los gif de la careforia y le pasamos por pros la categoria que estamos evaluando */\n                     ))\n                 }\n             </ol>\n         </>\n     );\n };\n\n export default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport GifExpertApp from './GifExpertApp';\nimport './index.css';\n\n\n\nReactDOM.render(\n  <GifExpertApp/>,\n   document.getElementById('root')\n);\n"],"sourceRoot":""}